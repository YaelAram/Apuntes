Para esto utilizamos el objeto *Connection* en conjunto con *Statement / PreparedStatement* y *ResultSet*.

**Nota: Al realizar un *query* el método *next* del *ResultSet* mueve el cursor al siguiente registro encontrado, si no lo hay retorna *false*. Su posición inicial es una fila antes del primer registro encontrado.**

**Nota: Tanto *Statement*, *PreparedStatement* y *ResultSet* implementan la interfaz *AutoClosable*.**

Método para realizar el *mapping* entre la información actual en un *ResultSet* y un objeto de nuestra aplicación Java:

```
private Product mapProduct(ResultSet resultSet) throws SQLException {
    long idProd = resultSet.getLong("idProd");
    String name = resultSet.getString("name");
    BigDecimal price = resultSet.getBigDecimal("price");
    LocalDateTime createdAt = resultSet
	    .getTimestamp("createdAt").toLocalDateTime();

    long idCat = resultSet.getLong("idCat");
    String nameCat = resultSet.getString("nameCat");

    return new Product(idProd, name, price, createdAt, 
	    new Category(idCat, nameCat));
}
```

**Nota: Utilizamos el método getTimestamp si nuestra columna es tipo TIMESTAMP o DATETIME con el fin de obtener la fecha y hora. Si nuestra columna es tipo DATE utilizar el método *getDate*.**

Obtener todos los registros de una tabla:

```
@Override
public List<Product> findAll(int limit, int skip) {
    String query = "SELECT * FROM products";
    List<Product> products = new ArrayList<>();

    try (Statement statement = this.getConnection().createStatement(query)) {
        try (ResultSet resultSet = statement.executeQuery()) {
            while (resultSet.next()) {
                Product product = this.mapProduct(resultSet);
                products.add(product);
            }
        }
    } catch (SQLException ex) { System.out.println("Error: " + ex.getMessage()); }
    
    return products;
}
```

Realizar un *join* y paginar los registros:

```
@Override
public List<Product> findAll(int limit, int skip) {
    String query = """
    SELECT p.*, c.name as nameCat FROM products as p
        INNER JOIN categories as c ON (p.idCat = c.idCat)
        ORDER BY idProd LIMIT ? OFFSET ?
    """;
    List<Product> products = new ArrayList<>();

    try (
	    PreparedStatement statement = this.getConnection().prepareStatement(query)
	) {
        statement.setInt(1, limit);
        statement.setInt(2, skip);

        try (ResultSet resultSet = statement.executeQuery()) {
            while (resultSet.next()) {
                Product product = this.mapProduct(resultSet);
                products.add(product);
            }
        }
    } catch (SQLException ex) { System.out.println("Error: " + ex.getMessage()); }
    
    return products;
}
```

Obtener registros por ID:

```
@Override
public Optional<Product> findById(long id) {
    String query = """
        SELECT p.*, c.name as nameCat FROM products as p
        INNER JOIN categories as c ON (p.idCat = c.idCat)
        WHERE idProd = ?
    """;
    Optional<Product> product = Optional.empty();

    try (
	    PreparedStatement statement = this.getConnection().prepareStatement(query)
	) {
        statement.setLong(1, id);

        try (ResultSet resultSet = statement.executeQuery()) {
            if (resultSet.next()) 
	            product = Optional.of(this.mapProduct(resultSet));
        }
    } catch (SQLException ex) { System.out.println("Error: " + ex.getMessage()); }

    return product;
}
```

**Nota: Dado que solo buscamos un registro, podemos utilizar un *if* en lugar de iterar con un *while loop*.**