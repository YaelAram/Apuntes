El manejo de transacciones con JDBC no difiere mucho al flujo de trabajo utilizando sentencias SQL individuales. Por defecto, las sentencias ejecutadas en una conexión de JDBC realizan un *commit* automático al final de cada una de ellas.

Con el fin de realizar una transacción en una conexión JDBC debemos realizar lo siguiente:

```
IRepository<Product> repository = new ProductRepository();

try (Connection conn = DbConnection.getConnection()) {
    conn.setAutoCommit(false);

    try {
        repository.createItem(
	        new Product(
                -1, "FIFA 26", new BigDecimal("59.99"), LocalDateTime.now(),
                new Category(2, "")
            )
        );
        repository.deleteItem(60);

        conn.commit();
    } catch (Exception ex) {
        System.out.println(ex.getMessage());
        conn.rollback();
    }

	conn.setAutoCommit(true);
} catch (SQLException ex) {
    System.out.println(ex.getMessage());
}
```

**Nota: En este ejemplo el método *getConnection* puede tratarse de una conexión implementada en un patrón *singleton* o una conexión de un *pool*.**

Donde:

- Utilizamos el método *setAutoCommit* para indicar si los cambios realizados por las sentencias SQL deben ser inmediatamente ejecutados sobre la base de datos.
- Al final del *try block* con todas nuestras sentencias SQL ejecutadas exitosamente, podemos ejecutar el método *commit* con el fin de plasmar los cambios en la base de datos.
- Mientras que en el *catch* ejecutamos el método *rollback* para revertir todos los cambios ya que alguna de las sentencias SQL fallo.

**Nota: Los métodos *commit* y *rollback* deben ejecutarse en la misma conexión que ejecuto el resto de sentencias SQL de la transacción.**